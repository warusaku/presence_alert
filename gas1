/**
 * Omada Webhook 受信用 (Google Apps Script) - 修正版
 * 2025-07-10 出勤簿連携・Discord通知対応版
 */

function doPost(e) {
  /* ---------- 1. 受信 ---------- */
  const raw     = (e.postData && e.postData.contents) ? e.postData.contents : '{}';
  const payload = _safeJson_(raw);

  /* ---------- 2. ログ保存（全件） ---------- */
  _writeLog_(payload);

  /* ---------- 3. MAC / ステータス / IP / 時刻 抽出 ---------- */
  const info = _extractInfo_(payload);
  if (!info.macRaw || !info.status) return _ok_();

  const macNorm = _normalizeMac_(info.macRaw);

  /* ---------- 4. mac シート照合 ---------- */
  const ss        = SpreadsheetApp.getActiveSpreadsheet();
  const macSheet  = ss.getSheetByName('mac') || ss.insertSheet('mac');
  const macData   = _getMacData_(macSheet);
  
  if (!macData.has(macNorm)) return _ok_();
  
  const macInfo   = macData.get(macNorm);
  const dispName  = macInfo.displayName;
  const username  = macInfo.username;
  const endpoint  = macInfo.gasEndpoint;
  const webhook   = macInfo.discordWebhook;

  /* ---------- 5. data シートへ書き込み ---------- */
  const dataSheet = ss.getSheetByName('data') || ss.insertSheet('data');
  const newRow = [
    info.eventDate,
    info.macRaw.toUpperCase(),
    dispName,
    info.status,
    info.ip || '',
    JSON.stringify(payload)
  ];
  dataSheet.appendRow(newRow);

  /* ---------- 6. 出勤判定ロジック ---------- */
  const judgmentResult = _judgeAttendance_(dataSheet, macSheet, username, info.status, info.eventDate);
  
  /* ---------- 7. 出勤簿エンドポイントへ送信 ---------- */
  if (endpoint) {
    const postData = {
      username: username,
      timestamp: _formatDateTime_(info.eventDate),
      state: info.status,
      name: username,
      devicename: dispName,
      ipaddr: info.ip || '',
      MAC: info.macRaw.toUpperCase(),
      description: judgmentResult.description
    };
    
    try {
      UrlFetchApp.fetch(endpoint, {
        method: 'post',
        contentType: 'application/json',
        payload: JSON.stringify(postData)
      });
    } catch(e) {
      console.error('出勤簿エンドポイントへの送信エラー:', e);
    }
  }

  /* ---------- 8. Discord通知 ---------- */
  if (webhook) {
    _sendDiscordNotification_(webhook, username, dispName, info.status, judgmentResult.description, info.eventDate);
  }

  return _ok_();
}

/* ================================================================= */
/* 出勤判定ロジック ------------------------------------------------- */
/* ================================================================= */

function _judgeAttendance_(dataSheet, macSheet, username, currentStatus, eventDate) {
  const lastRow = dataSheet.getLastRow();
  if (lastRow <= 1) {
    return currentStatus === 'ONLINE' 
      ? {description: '出勤(最初のエントリ)'} 
      : {description: 'OFFLINE(最初のエントリ)'};
  }

  // 全データを取得（最新のものから処理）
  const allData = dataSheet.getRange(2, 1, lastRow - 1, 6).getValues().reverse();
  const macData = _getMacData_(macSheet);
  
  // 同一ユーザーの全デバイスを取得
  const userDevices = _getUserDevices_(macData, username);
  
  // 現在の日付を取得
  const currentDateStr = _formatDate_(eventDate);
  
  // 同一日の同一ユーザーのエントリを検索
  let sameDayEntry = null;
  let previousEntry = null;
  let otherDeviceOnline = false;
  
  for (let i = 0; i < allData.length; i++) {
    const row = allData[i];
    const rowDate = row[0];
    const rowMac = _normalizeMac_(row[1]);
    const rowStatus = row[3];
    
    // MACアドレスからユーザー名を取得
    const rowUserInfo = macData.get(rowMac);
    if (!rowUserInfo) continue;
    
    const rowUsername = rowUserInfo.username;
    const rowDateStr = _formatDate_(rowDate);
    
    // 同一ユーザーの場合
    if (rowUsername === username) {
      // 別デバイスがオンラインかチェック
      if (rowMac !== _normalizeMac_(dataSheet.getRange(lastRow, 2).getValue()) && 
          rowStatus === 'ONLINE' && 
          rowDateStr === currentDateStr) {
        otherDeviceOnline = true;
      }
      
      // 同一日のエントリ
      if (rowDateStr === currentDateStr && !sameDayEntry) {
        sameDayEntry = {row: row, index: i};
      }
      
      // 前のエントリ（日付問わず）
      if (!previousEntry) {
        previousEntry = {row: row, index: i, dateStr: rowDateStr};
      }
    }
  }
  
  // 判定ロジック
  let description = '';
  
  if (!sameDayEntry) {
    // 同一日のエントリがない場合
    if (currentStatus === 'ONLINE') {
      description = '出勤(最初のエントリ)';
      
      // 前日最後のOFFLINEを退勤と判定
      if (previousEntry && previousEntry.row[3] === 'OFFLINE' && previousEntry.dateStr !== currentDateStr) {
        const rowIndex = lastRow - previousEntry.index - 1;
        dataSheet.getRange(rowIndex, 7).setValue('前日最後のOFFLINE=退勤と判定');
      }
    } else {
      description = 'OFFLINE(本日の最初のエントリ)';
    }
  } else {
    // 同一日のエントリがある場合
    if (currentStatus === 'OFFLINE') {
      description = 'OFFLINE=デバイスがwifiから切断されました';
    } else if (currentStatus === 'ONLINE') {
      // 前回のステータスを確認
      const prevStatus = sameDayEntry.row[3];
      if (prevStatus === 'OFFLINE') {
        // インターバル計算
        const interval = _calculateInterval_(sameDayEntry.row[0], eventDate);
        description = `ONLINEに復帰しました interval=${interval}`;
      } else {
        description = 'ONLINEに復帰しました前回OFFLINEが記録されてません';
      }
    }
  }
  
  // 別デバイスがオンラインの場合
  if (otherDeviceOnline && currentStatus === 'ONLINE') {
    description += ' //別の端末ではすでにONLINEへ復帰済み';
  }
  
  return {description: description};
}

/* ================================================================= */
/* Discord通知 ----------------------------------------------------- */
/* ================================================================= */

function _sendDiscordNotification_(webhook, username, devicename, status, description, eventDate) {
  const color = status === 'ONLINE' ? 0x00ff00 : 0xff0000;
  const statusEmoji = status === 'ONLINE' ? '🟢' : '🔴';
  
  const embed = {
    embeds: [{
      title: `${statusEmoji} ${username} - ${status}`,
      description: description,
      color: color,
      fields: [
        {
          name: 'デバイス名',
          value: devicename,
          inline: true
        },
        {
          name: '時刻',
          value: _formatDateTime_(eventDate),
          inline: true
        }
      ],
      timestamp: eventDate.toISOString()
    }]
  };
  
  try {
    UrlFetchApp.fetch(webhook, {
      method: 'post',
      contentType: 'application/json',
      payload: JSON.stringify(embed)
    });
  } catch(e) {
    console.error('Discord通知エラー:', e);
  }
}

/* ================================================================= */
/* ユーティリティ関数 ----------------------------------------------- */
/* ================================================================= */

function _ok_(){
  // Omadaが期待する形式でレスポンスを返す
  const response = ContentService.createTextOutput(JSON.stringify({
    status: 'success',
    message: 'Webhook received successfully'
  }));
  
  response.setMimeType(ContentService.MimeType.JSON);
  
  // HTTPステータスコードを明示的に200に設定
  return response;
}

function _safeJson_(txt){
  try { return JSON.parse(txt); }
  catch(e){ return { parseError: e.toString(), raw: txt }; }
}

function _normalizeMac_(m){
  return m.replace(/[^0-9A-Fa-f]/g,'').toUpperCase();
}

function _eventStatus_(msg=''){
  const m = msg.toLowerCase();
  if (m.includes('went online') || m.includes('online')  || m.includes('オンライン'))  return 'ONLINE';
  if (m.includes('went offline')|| m.includes('offline') || m.includes('オフライン')) return 'OFFLINE';
  return '';
}

function _getMacData_(sheet){
  const rows = sheet.getLastRow();
  if (rows === 0) return new Map();

  const vals = sheet.getRange(1, 1, rows, 5).getValues();
  const map  = new Map();
  vals.forEach(r => {
    if (r[0]) {
      map.set(_normalizeMac_(r[0]), {
        displayName: r[1] || '',
        gasEndpoint: r[2] || '',
        username: r[3] || '',
        discordWebhook: r[4] || ''
      });
    }
  });
  return map;
}

function _getUserDevices_(macData, username) {
  const devices = [];
  macData.forEach((value, key) => {
    if (value.username === username) {
      devices.push(key);
    }
  });
  return devices;
}

function _writeLog_(payload){
  const ss    = SpreadsheetApp.getActiveSpreadsheet();
  const logSh = ss.getSheetByName('log') || ss.insertSheet('log');
  logSh.appendRow([new Date(), JSON.stringify(payload)]);
}

function _extractInfo_(obj){
  let macRaw = '', status = '', ip = '';

  if (obj.data && obj.data.clientMac){
    macRaw = obj.data.clientMac;
    ip     = obj.data.clientIp || '';
    status = _eventStatus_(obj.msg || '');
  } else if (Array.isArray(obj.text) && obj.text[0]){
    const line = obj.text[0];
    macRaw = (line.match(/client:[^:\]]+:([0-9A-Fa-f:-]+)/) || [])[1] || '';
    ip     = (line.match(/IP:\s*([0-9.]+)/)               || [])[1] || '';
    status = _eventStatus_(line);
  }

  const ms        = Number(obj.timestamp) || Date.now();
  let   eventDate = new Date(ms);

  return { macRaw, status, ip, eventDate };
}

function _formatDate_(date) {
  return Utilities.formatDate(date, 'Asia/Tokyo', 'yyyy/MM/dd');
}

function _formatDateTime_(date) {
  return Utilities.formatDate(date, 'Asia/Tokyo', 'yyyy/MM/dd HH:mm:ss');
}

function _calculateInterval_(startDate, endDate) {
  const diff = endDate.getTime() - startDate.getTime();
  const hours = Math.floor(diff / (1000 * 60 * 60));
  const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
  const seconds = Math.floor((diff % (1000 * 60)) / 1000);
  
  return `${hours}時間${minutes}分${seconds}秒`;
}

/* ================================================================= */
/* テスト用関数（開発時のみ使用） ------------------------------------ */
/* ================================================================= */

function testSetup() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  
  // macシートのセットアップ
  const macSheet = ss.getSheetByName('mac') || ss.insertSheet('mac');
  if (macSheet.getLastRow() === 0) {
    macSheet.getRange(1, 1, 1, 5).setValues([
      ['MACアドレス', 'デバイス名', 'GASエンドポイント', 'ユーザー名', 'Discord Webhook']
    ]);
  }
  
  // dataシートのセットアップ  
  const dataSheet = ss.getSheetByName('data') || ss.insertSheet('data');
  if (dataSheet.getLastRow() === 0) {
    dataSheet.getRange(1, 1, 1, 7).setValues([
      ['タイムスタンプ', 'MAC', '表示名', 'ステータス', 'IP', '元JSON', '判定内容']
    ]);
  }
  
  // logシートのセットアップ
  const logSheet = ss.getSheetByName('log') || ss.insertSheet('log');
  if (logSheet.getLastRow() === 0) {
    logSheet.getRange(1, 1, 1, 2).setValues([
      ['受信時刻', 'ペイロード']
    ]);
  }
}

/**
 * Webhook動作確認用関数
 * Omadaからのテストリクエストをシミュレート
 */
function testWebhook() {
  const testPayload = {
    postData: {
      contents: JSON.stringify({
        timestamp: Date.now(),
        data: {
          clientMac: "AA:BB:CC:DD:EE:FF",
          clientIp: "192.168.1.100"
        },
        msg: "Client AA:BB:CC:DD:EE:FF went online"
      })
    }
  };
  
  const result = doPost(testPayload);
  console.log('Test Result:', result.getContent());
}